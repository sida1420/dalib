import random
from collections import defaultdict
import queue

import Initialize,Selection,Crossover,Mutation

def binPackingGA(boxes:list, bin: int):

    #How many in each generation
    gensSize=100
    #Loop
    end=100
    bestScore=10**12
    bestGen=[]
    
    gens=[Initialize.init(boxes) for i in range(0,gensSize)]

    #Selection percent: 40%
    #Crossover percent: 100%
    #Mutation percent: 100% (until meet gen size)
    for i in range(0,end):
        print("\tNEW GEN")
        score, gens=Selection.selection(gens,0.4,boxes,bin)
        if bestScore>=score:
            bestScore=score
            bestGen=gens[0]

        gens=Crossover.crossover(gens,1)
        gens=Mutation.mutation(gens,0.8, gensSize)

    print("\tBEST\n",bestScore,[boxes[i] for i in bestGen])
    
    return bestScore
    

def binPackingBF(boxes: list, bin: int):
    
    best=[len(boxes)]

    def dfs(current, binUsed, boxUsed, left,best):

        if binUsed>best[0]:
            return
        if left==0:
            best[0]=min(best[0],binUsed)
            return

        for b in boxes:
            if boxUsed[b]==0:
                continue
            
            boxUsed[b]-=1
            if b+current>bin:
                dfs(b, binUsed+1,boxUsed,left-1,best)
            else:
                dfs(current+b,binUsed,boxUsed,left-1,best)

                
            boxUsed[b]+=1
            
        
    boxUsed={}
    for box in boxes:
        boxUsed[box]=boxUsed.get(box,0)+1

    dfs(0,1,boxUsed,len(boxes),best)

    return best[0]

    



#   TEST CASES GENERATED BY CHATGPT
#   Hard: 5,8,2

# testcase 1: Tiny & huge mix — “many tiny fillers”
# bin_capacity = 100
# items = [99, 99] + [1]*9
# sum = 207, LB = 3

#testcase 2: Many similar halves — “pairing required”
# bin_capacity = 100
# items = [51]*7 + [49]*7 + [50]*2
# sum = 800, LB = 8

#testcase 3: Multimodal clusters
# bin_capacity = 100
# items = [60,60,60, 40,40,40, 20,20,20,20, 10,10,10, 5,5,5]
# sum = 425, LB = 5

#testcase 4: Dense small items (many pieces)
# bin_capacity = 100
# items = [5]*30 + [7]*10 + [13]*5
# sum = 285, LB = 3

#testcase 5: Large primes & near-full items
bin_capacity = 100
items = [97,89,83,79,73,71,67,61,59,53,47,43,41,37,31,29,23,19,17,13,11,7,5,3,2]
# sum = 1060, LB = 11

#testcase 6: Fraction-like pieces (33/34)
# bin_capacity = 100
# items = [34,34,34, 33,33,33, 1,1,1,1]
# sum = 205, LB = 3

#testcase 7: Decreasing adversarial
# bin_capacity = 100
# items = [64,64,64, 36,36,36, 35,35,35, 1,1,1,1]
# sum = 409, LB = 5

# testcase 8: Patterned pairs with mid items
# bin_capacity = 100
# items = [70,30, 70,30, 66,34, 66,34, 50,50, 49,51, 25,25,25,25]
# sum = 700, LB = 7

#testcase 9: Fibonacci / skewed large + many tiny
# bin_capacity = 100
# items = [89,55,34,21,13,8,5,3,2,1,1,1]
# sum = 233, LB = 3

#testcase 10: Large capacity, heterogeneous sizes
# bin_capacity = 1000
# items = [600,400,500,500,250,250,250,250,125,125,125,125, 60,60,60,60,60,60, 30,30,30,30, 10,10,10,10]
# sum = 4020, LB = 5

#testcase 11: Many small edge pieces (pairs + many 2s)
# bin_capacity = 100
# items = [51,49, 51,49, 51,49] + [2]*8
# sum = 316, LB = 4

# testcase 12: Challenging multiset (lots of 45/50/20/10 leftovers)
# bin_capacity = 100
# items = [45,45,45,45, 10,10,10,10, 20,20,20,20, 5,5,5,5, 50,50,50]
# sum = 470, LB = 5


binPackingGA(items,bin_capacity)


