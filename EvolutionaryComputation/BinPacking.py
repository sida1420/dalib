import random
from collections import defaultdict
import queue

import BinPacking.Initialize

def binPacking(boxes:list, bin: int):

    #How many in each generation
    gensSize=100

    
    


    def numOfBins(gen: list, bin: int):
        current=0
        count=1
        for i in gen:
            if i+current<=bin:
                current+=i
            else:
                count+=1
                current=i

        return count

    def numOfBinsAndHowFullEach(gen: list, bin: int, maxBoxes: int):
        current=0
        point=1.0
        for i in gen:
            if i+current<=bin:
                current+=i
            else:
                point+=1.0+(bin-current)/bin/maxBoxes
                current=i

        return point


    def evalua(gen: list):
        return numOfBinsAndHowFullEach(gen,bin,len(boxes))

    

    def selection(gens , percent):
        ranking=[]
        for gen in gens:
            ranking.append((evalua(gen),gen))

        ranking.sort()

        # for score, gen in ranking:
        #     print(score, gen)

        newGens=[]
        n=int(len(ranking)*percent)
        for i in range(0,n):
            newGens.append(ranking[i][1])

        return ranking[0][0],newGens



    def cycleCrossover(parent1, parent2, start):

        child=[0 for i in range(len(parent1))]


        child[start]=parent1[start]
        ha=defaultdict(list)
        for i in range(len(parent2)):
            ha[parent2[i]].append(i)

        current=ha[parent1[start]].pop()
        while current!=start:
            child[current]=parent1[current]
            current=ha[parent1[current]].pop()

        i=start+1
        while i<len(parent1) and child[i]!=0:
            i+=1
        if i>=len(parent1):
            return child
        # print(child)
        subChild=cycleCrossover(parent2,parent1,i)
        for i in range(len(parent1)):
            if child[i]==0:
                child[i]=subChild[i]

        return child

    def crossover(gens, percent):        
        newGens=[]
        n=int(len(gens)*percent)-1
        for i in range(0,n,2):
            newGens.append(cycleCrossover(gens[i],gens[i+1],0))
            newGens.append(cycleCrossover(gens[i+1],gens[i],0))
        # print(newGens)
        return newGens
    

    def mutation(gens, percent):
        target=0
        newGens=[]
        while len(gens)+len(newGens)<gensSize:
            gen=gens[target].copy()
            rate=random.random()
            if rate<percent:

                i=random.randint(0,len(gens[target])-1)
                j=random.randint(0,len(gens[target])-1)
                gen[i], gen[j] = gen[j], gen[i]
            
            newGens.append(gen)
            target=(target+1)%len(gens)

        return newGens+gens

    #Loop
    end=100
    bestScore=len(boxes)
    bestGen=[]
    
    gens=[init() for i in range(0,gensSize)]

    for i in range(0,end):
        # print("\tNEW GEN")
        score, gens=selection(gens,0.5)
        if bestScore>=score:
            bestScore=score
            bestGen=gens[0]
        

        gens=crossover(gens,1)
        gens=mutation(gens,1)

    print("\tBEST\n",bestScore,bestGen)
    # print(gens)

#   TEST CASES GENERATED BY CHATGPT
#   Hard: 5,8,2 (Near impossible: 5)

# testcase 1: Tiny & huge mix — “many tiny fillers”
# bin_capacity = 100
# items = [99, 99] + [1]*9
# sum = 207, LB = 3

#testcase 2: Many similar halves — “pairing required”
# bin_capacity = 100
# items = [51]*7 + [49]*7 + [50]*2
# sum = 800, LB = 8

#testcase 3: Multimodal clusters
# bin_capacity = 100
# items = [60,60,60, 40,40,40, 20,20,20,20, 10,10,10, 5,5,5]
# sum = 425, LB = 5

#testcase 4: Dense small items (many pieces)
# bin_capacity = 100
# items = [5]*30 + [7]*10 + [13]*5
# sum = 285, LB = 3

#testcase 5: Large primes & near-full items
bin_capacity = 100
items = [97,89,83,79,73,71,67,61,59,53,47,43,41,37,31,29,23,19,17,13,11,7,5,3,2]
# sum = 1060, LB = 11

#testcase 6: Fraction-like pieces (33/34)
# bin_capacity = 100
# items = [34,34,34, 33,33,33, 1,1,1,1]
# sum = 205, LB = 3

#testcase 7: Decreasing adversarial
# bin_capacity = 100
# items = [64,64,64, 36,36,36, 35,35,35, 1,1,1,1]
# sum = 409, LB = 5

# testcase 8: Patterned pairs with mid items
# bin_capacity = 100
# items = [70,30, 70,30, 66,34, 66,34, 50,50, 49,51, 25,25,25,25]
# sum = 700, LB = 7

#testcase 9: Fibonacci / skewed large + many tiny
# bin_capacity = 100
# items = [89,55,34,21,13,8,5,3,2,1,1,1]
# sum = 233, LB = 3

#testcase 10: Large capacity, heterogeneous sizes
# bin_capacity = 1000
# items = [600,400,500,500,250,250,250,250,125,125,125,125, 60,60,60,60,60,60, 30,30,30,30, 10,10,10,10]
# sum = 4020, LB = 5

#testcase 11: Many small edge pieces (pairs + many 2s)
# bin_capacity = 100
# items = [51,49, 51,49, 51,49] + [2]*8
# sum = 316, LB = 4

# testcase 12: Challenging multiset (lots of 45/50/20/10 leftovers)
# bin_capacity = 100
# items = [45,45,45,45, 10,10,10,10, 20,20,20,20, 5,5,5,5, 50,50,50]
# sum = 470, LB = 5

binPacking(items,bin_capacity)
